<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BioDigital Twins | High-Fidelity</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/math/MeshSurfaceSampler.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
    <style>
        :root {
            --bg-color: #050505;
            --card-bg: rgba(20, 20, 20, 0.6);
            --border-color: rgba(255, 255, 255, 0.08);
            --accent-glow: rgba(255, 255, 255, 0.03);
            --text-primary: #ffffff;
            --text-secondary: #888888;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at 50% 0%, #1a1a1a 0%, #000000 70%);
            font-family: 'Inter', 'Segoe UI', Roboto, sans-serif;
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
            min-height: 100vh;
        }

        /* Typography */
        h2 { 
            margin-top: 60px; 
            font-weight: 200; 
            letter-spacing: 6px; 
            text-transform: uppercase; 
            font-size: 2rem;
            background: linear-gradient(180deg, #fff, #666);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }
        
        .sub-text { 
            color: var(--text-secondary); 
            margin-bottom: 60px; 
            font-size: 0.9rem; 
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0.8;
        }
        
        /* Grid Layout */
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 40px;
            padding: 20px;
            max-width: 1400px;
            width: 90%;
            padding-bottom: 80px;
        }
        
        /* Glassmorphism Card */
        .card {
            background: var(--card-bg);
            border-radius: 16px;
            overflow: hidden;
            position: relative;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            box-shadow: 0 20px 40px rgba(0,0,0,0.6);
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), 
                        box-shadow 0.4s ease, 
                        border-color 0.4s ease;
        }

        .card:hover {
            transform: translateY(-8px);
            box-shadow: 0 30px 60px rgba(0,0,0,0.8), 0 0 20px var(--accent-glow);
            border-color: rgba(255,255,255,0.2);
        }
        
        /* Canvas */
        .canvas-container {
            width: 100%;
            height: 400px;
            position: relative;
            cursor: grab;
        }
        .canvas-container:active { cursor: grabbing; }
        
        /* Overlay UI */
        .card-footer {
            padding: 20px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid var(--border-color);
            background: rgba(0,0,0,0.3);
        }

        .label {
            font-size: 0.75rem;
            font-weight: 600;
            color: #ccc;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .status-dot {
            height: 8px;
            width: 8px;
            background-color: #00ff88;
            border-radius: 50%;
            box-shadow: 0 0 8px #00ff88;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.5; box-shadow: 0 0 0px #00ff88; }
            50% { opacity: 1; box-shadow: 0 0 10px #00ff88; }
            100% { opacity: 0.5; box-shadow: 0 0 0px #00ff88; }
        }

        @media (max-width: 900px) { 
            .grid { grid-template-columns: 1fr; } 
            h2 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>

    <h2>Biomimetic Structures</h2>
    <div class="sub-text">Interactive Digital Twins</div>

    <div class="grid">
        <div class="card">
            <div id="heart-container" class="canvas-container"></div>
            <div class="card-footer">
                <div class="label">Human Heart</div>
                <div class="status-dot" style="background-color: #ff4444; box-shadow: 0 0 8px #ff4444;"></div>
            </div>
        </div>
        
        <!-- <div class="card">
            <div id="lungs-container" class="canvas-container"></div>
            <div class="card-footer">
                <div class="label">Respiratory System</div>
                <div class="status-dot" style="background-color: #ff9999; box-shadow: 0 0 8px #ff9999;"></div>
            </div>
        </div> -->
        
        <div class="card">
            <div id="nerve-container" class="canvas-container"></div>
            <div class="card-footer">
                <div class="label">Multipolar Neuron</div>
                <div class="status-dot" style="background-color: #00eaff; box-shadow: 0 0 8px #00eaff;"></div>
            </div>
        </div>
        
        <div class="card">
            <div id="bone-container" class="canvas-container"></div>
            <div class="card-footer">
                <div class="label">Femur Structure</div>
                <div class="status-dot" style="background-color: #fffdd0; box-shadow: 0 0 8px #fffdd0;"></div>
            </div>
        </div>
    </div>

    <script>
        // =========================================
        // GLOBAL INTERACTION
        // =========================================
        const mouse = { x: 0, y: 0 };
        const targetRotation = { x: 0, y: 0 };
        
        document.addEventListener('mousemove', (e) => {
            // Normalize mouse position -1 to 1
            const x = (e.clientX / window.innerWidth) * 2 - 1;
            const y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            targetRotation.x = y * 0.5; // Limit vertical rotation
            targetRotation.y = x * 0.8; 
        });

        // =========================================
        // HELPERS
        // =========================================
        
        // 1. ORGAN GENERATOR (Upgraded Materials)
        function createOrgan(geometry, color, count, particleSize = 0.12) {
            const group = new THREE.Group();

            // A. The Inner Core (Physical Material for "Wet/Organic" look)
            const coreMat = new THREE.MeshPhysicalMaterial({
                color: color,
                roughness: 0.4,
                metalness: 0.1,
                clearcoat: 1.0,       // Makes it look wet
                clearcoatRoughness: 0.1,
                transparent: true,
                opacity: 0.85,
                side: THREE.DoubleSide
            });
            const coreMesh = new THREE.Mesh(geometry.clone(), coreMat);
            coreMesh.scale.set(0.92, 0.92, 0.92); 
            group.add(coreMesh);

            // B. The Cellular Surface (Particles)
            const sampler = new THREE.MeshSurfaceSampler(new THREE.Mesh(geometry, new THREE.MeshBasicMaterial())).build();
            const partGeo = new THREE.SphereGeometry(particleSize, 8, 8); // Slightly higher res
            
            // Glowing particle material
            const partMat = new THREE.MeshPhysicalMaterial({ 
                color: color, 
                emissive: color,
                emissiveIntensity: 0.3,
                roughness: 0.2,
                clearcoat: 1.0
            });
            
            const instancedMesh = new THREE.InstancedMesh(partGeo, partMat, count);
            const dummy = new THREE.Object3D();
            const pos = new THREE.Vector3();
            const nor = new THREE.Vector3();

            for (let i = 0; i < count; i++) {
                sampler.sample(pos, nor);
                pos.addScaledVector(nor, (Math.random() - 0.5) * 0.2);
                dummy.position.copy(pos);
                
                const s = 0.5 + Math.random() * 1.0;
                dummy.scale.set(s, s, s);
                dummy.lookAt(pos.clone().add(nor));
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(i, dummy.matrix);
            }
            instancedMesh.instanceMatrix.needsUpdate = true;
            
            group.add(instancedMesh);
            return group;
        }

        // 2. BACKGROUND PARTICLES (Floating Bubbles)
        function addFloatingParticles(scene, color, count = 50) {
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.4,
                blending: THREE.AdditiveBlending
            });

            const particles = [];
            for (let i = 0; i < count; i++) {
                const mesh = new THREE.Mesh(geometry, material);
                
                // Random position spread
                mesh.position.set(
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 10 - 5 // Push slightly back
                );
                
                // Store random speed and offset
                mesh.userData = {
                    speed: 0.02 + Math.random() * 0.05,
                    offset: Math.random() * Math.PI * 2,
                    amp: 0.5 + Math.random() * 0.5
                };
                
                // Random Scale
                const s = 0.5 + Math.random() * 2.0;
                mesh.scale.set(s,s,s);

                scene.add(mesh);
                particles.push(mesh);
            }
            return particles;
        }


        // =========================================
        // MODELS (Geometry logic preserved)
        // =========================================

        function createHeartModel() {
            const containerGroup = new THREE.Group();
            const redGeos = [];
            const leftVentricle = new THREE.SphereGeometry(2.0, 32, 32); leftVentricle.applyMatrix4(new THREE.Matrix4().makeScale(0.8, 1.5, 0.8)); leftVentricle.translate(0.6, -0.5, 0); leftVentricle.rotateZ(0.2); redGeos.push(leftVentricle);
            const leftAtrium = new THREE.SphereGeometry(1.2, 24, 24); leftAtrium.translate(1.0, 1.5, -0.4); redGeos.push(leftAtrium);
            const aortaCurve = new THREE.CatmullRomCurve3([new THREE.Vector3(0.5, 1.5, 0), new THREE.Vector3(0.2, 2.8, 0), new THREE.Vector3(-0.5, 3.2, 0), new THREE.Vector3(-1.2, 2.5, 0), new THREE.Vector3(-1.2, 0.5, 0)]);
            const aortaGeo = new THREE.TubeGeometry(aortaCurve, 24, 0.6, 12, false); redGeos.push(aortaGeo);
            const redMerged = THREE.BufferGeometryUtils.mergeBufferGeometries(redGeos);
            const redTissue = createOrgan(redMerged, 0xd00000, 4000, 0.09); // Brighter Red
            containerGroup.add(redTissue);

            const blueGeos = [];
            const rightVentricle = new THREE.SphereGeometry(1.7, 32, 32); rightVentricle.applyMatrix4(new THREE.Matrix4().makeScale(0.9, 1.3, 0.9)); rightVentricle.translate(-0.8, -0.2, 0.6); blueGeos.push(rightVentricle);
            const rightAtrium = new THREE.SphereGeometry(1.3, 24, 24); rightAtrium.translate(-1.2, 1.2, 0.3); blueGeos.push(rightAtrium);
            const venaCurve = new THREE.LineCurve3(new THREE.Vector3(-1.6, 1.5, 0.2), new THREE.Vector3(-1.6, 3.2, 0));
            const venaGeo = new THREE.TubeGeometry(venaCurve, 8, 0.55, 12, false); blueGeos.push(venaGeo);
            const pulmCurve = new THREE.CatmullRomCurve3([new THREE.Vector3(-0.6, 0.8, 0.9), new THREE.Vector3(-0.4, 2.2, 0.7), new THREE.Vector3(0.8, 2.4, 0.5)]);
            const pulmGeo = new THREE.TubeGeometry(pulmCurve, 15, 0.5, 12, false); blueGeos.push(pulmGeo);
            const blueMerged = THREE.BufferGeometryUtils.mergeBufferGeometries(blueGeos);
            const blueTissue = createOrgan(blueMerged, 0x2255aa, 3500, 0.09); // Brighter Blue
            containerGroup.add(blueTissue);

            new THREE.Box3().setFromObject(containerGroup).getCenter(containerGroup.position).multiplyScalar(-1);
            return containerGroup;
        }

        // function createLungsModel() {
        //     const r1 = new THREE.SphereGeometry(1.9, 24, 24); r1.scale(1, 1.5, 1); r1.translate(2.4, 1.2, 0);
        //     const r2 = new THREE.SphereGeometry(1.8, 24, 24); r2.scale(1, 1.2, 1); r2.translate(2.6, -1.4, 0.2);
        //     const r3 = new THREE.SphereGeometry(1.7, 24, 24); r3.scale(1, 1.1, 1); r3.translate(2.7, -3.5, 0.1);
        //     const l1 = new THREE.SphereGeometry(1.8, 24, 24); l1.scale(1, 1.4, 1); l1.translate(-2.4, 1.4, 0);
        //     const l2 = new THREE.SphereGeometry(1.7, 24, 24); l2.scale(1, 1.6, 1); l2.translate(-2.5, -2.4, 0.2);
        //     const trachea = new THREE.CylinderGeometry(0.8, 0.8, 4.5, 16); trachea.translate(0, 3.5, 0);
        //     const lungGeo = THREE.BufferGeometryUtils.mergeBufferGeometries([r1, r2, r3, l1, l2, trachea]);
        //     const model = createOrgan(lungGeo, 0xaa0000, 5500, 0.11);
        //     model.position.y = 0.5;
        //     return model;
        // }

        function createNeuronModel() {
            const geos = [];
            const soma = new THREE.SphereGeometry(1.5, 32, 32);
            const posAttr = soma.attributes.position;
            for(let i=0; i<posAttr.count; i++) {
                const x = posAttr.getX(i); const y = posAttr.getY(i); const z = posAttr.getZ(i);
                const n = Math.sin(x*3) * Math.sin(y*2) * 0.2;
                posAttr.setXYZ(i, x+n, y+n, z+n);
            }
            soma.computeVertexNormals(); geos.push(soma);
            const axonCurve = new THREE.CatmullRomCurve3([new THREE.Vector3(0,0,0), new THREE.Vector3(2, -0.5, 0), new THREE.Vector3(5, 0.5, 0), new THREE.Vector3(8, -1, 0), new THREE.Vector3(10, 0, 0)]);
            const axon = new THREE.TubeGeometry(axonCurve, 30, 0.35, 8, false); geos.push(axon);
            function addBranch(start, dir, length, thickness, branches = 0) {
                const end = new THREE.Vector3().copy(start).add(dir.clone().multiplyScalar(length));
                const mid = new THREE.Vector3().lerpVectors(start, end, 0.5).add(new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5));
                const curve = new THREE.QuadraticBezierCurve3(start, mid, end);
                const tube = new THREE.TubeGeometry(curve, 8, thickness, 6, false); geos.push(tube);
                if (branches > 0) {
                    const numSub = 2;
                    for(let i=0; i<numSub; i++) {
                        const newDir = dir.clone().applyEuler(new THREE.Euler((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5))).normalize();
                        addBranch(end, newDir, length * 0.7, thickness * 0.6, branches - 1);
                    }
                }
            }
            for(let i=0; i<7; i++) {
                const angle = (i/7) * Math.PI * 2;
                const dir = new THREE.Vector3(-Math.cos(angle), Math.sin(angle), (Math.random()-0.5)).normalize();
                addBranch(new THREE.Vector3(-0.5, 0, 0), dir, 2.5, 0.3, 2);
            }
            addBranch(new THREE.Vector3(10,0,0), new THREE.Vector3(1, 0.5, 0).normalize(), 1.5, 0.2, 1);
            addBranch(new THREE.Vector3(10,0,0), new THREE.Vector3(1, -0.5, 0).normalize(), 1.5, 0.2, 1);
            const neuronGeo = THREE.BufferGeometryUtils.mergeBufferGeometries(geos);
            const model = createOrgan(neuronGeo, 0x00ffff, 6000, 0.08); // Cyan
            new THREE.Box3().setFromObject(model).getCenter(model.position).multiplyScalar(-1);
            model.scale.set(0.6, 0.6, 0.6);
            return model;
        }

        function createBoneModel() {
            const shaftCurve = new THREE.QuadraticBezierCurve3(new THREE.Vector3(0, -4.5, 0), new THREE.Vector3(0.3, 0, 0), new THREE.Vector3(0, 4.5, 0));
            const shaft = new THREE.TubeGeometry(shaftCurve, 24, 0.65, 16, false);
            const head = new THREE.SphereGeometry(1.4, 32, 32); head.translate(-1.4, 5.5, 0);
            const neck = new THREE.CylinderGeometry(0.55, 0.75, 1.8, 12); neck.rotateZ(0.7); neck.translate(-0.6, 4.8, 0);
            const troch = new THREE.SphereGeometry(1.1, 24, 24); troch.scale(0.8, 1.3, 0.8); troch.translate(0.7, 4.5, 0);
            const c1 = new THREE.SphereGeometry(1.3, 24, 24); c1.scale(0.9, 1.1, 1.2); c1.translate(-0.7, -5.2, 0.2);
            const c2 = new THREE.SphereGeometry(1.3, 24, 24); c2.scale(0.9, 1.1, 1.2); c2.translate(0.7, -5.2, 0.2);
            const bridge = new THREE.CylinderGeometry(1.0, 1.0, 1.4, 12); bridge.rotateZ(Math.PI / 2); bridge.translate(0, -5.0, 0.2);
            const boneGeo = THREE.BufferGeometryUtils.mergeBufferGeometries([shaft, head, neck, troch, c1, c2, bridge]);
            const model = createOrgan(boneGeo, 0xfffff0, 7500, 0.07);
            model.rotation.z = 0.2; 
            model.scale.set(0.85, 0.85, 0.85); 
            return model;
        }

        // =========================================
        // SCENE ENGINE
        // =========================================
        function initScene(containerId, createModelFn, animateFn, config) {
            const container = document.getElementById(containerId);
            const scene = new THREE.Scene();
            
            // Camera
            const camera = new THREE.PerspectiveCamera(35, container.offsetWidth / container.offsetHeight, 0.1, 100);
            camera.position.z = 16;

            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.offsetWidth, container.offsetHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);

            // 1. Lighting (Professional Studio Setup)
            scene.add(new THREE.AmbientLight(0xffffff, 0.2)); // Soft fill
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
            mainLight.position.set(5, 5, 10);
            scene.add(mainLight);

            const rimLight = new THREE.SpotLight(config.rim, 2.0);
            rimLight.position.set(-5, 5, -5);
            rimLight.lookAt(0,0,0);
            scene.add(rimLight);

            // 2. Load Model
            const modelGroup = createModelFn();
            scene.add(modelGroup);

            // 3. Floating Particles
            const particles = addFloatingParticles(scene, config.rim);

            // Animation Loop
            const clock = new THREE.Clock();
            
            function render() {
                requestAnimationFrame(render);
                const t = clock.getElapsedTime();
                
                // Custom Organ Animation
                animateFn(modelGroup, t);
                
                // Smooth Mouse Interaction (Damping)
                modelGroup.rotation.y += (targetRotation.y - modelGroup.rotation.y) * 0.05;
                modelGroup.rotation.x += (targetRotation.x - modelGroup.rotation.x) * 0.05;

                // Animate Floating Particles
                particles.forEach((p, i) => {
                    p.position.y += p.userData.speed * Math.sin(t * 0.5 + p.userData.offset);
                    // Wrap around if they go too high
                    if(p.position.y > 10) p.position.y = -10;
                });
                
                renderer.render(scene, camera);
            }
            render();

            // Resize Handler
            window.addEventListener('resize', () => {
                if(!container.offsetWidth) return;
                camera.aspect = container.offsetWidth / container.offsetHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.offsetWidth, container.offsetHeight);
            });
        }

        // =========================================
        // INIT ALL INSTANCES
        // =========================================

        initScene('heart-container', createHeartModel, (m, t) => {
            const period = 1.0;
            const phase = t % period;
            let s = 1;
            if(phase < 0.15) s = 1.08; 
            else if(phase > 0.25 && phase < 0.4) s = 1.04;
            m.scale.lerp(new THREE.Vector3(s, s, s), 0.2);
        }, { rim: 0xff3333 });

        // initScene('lungs-container', createLungsModel, (m, t) => {
        //     const b = 1 + Math.sin(t * 1.5) * 0.04;
        //     m.scale.set(b, 1 + (b-1)*0.5, b);
        // }, { rim: 0xffaaaa });

        initScene('nerve-container', createNeuronModel, (m, t) => {
            m.rotation.z = Math.sin(t * 0.5) * 0.05;
            const pulse = 0.6 + Math.sin(t * 4) * 0.02;
            m.scale.set(pulse, pulse, pulse);
        }, { rim: 0x00ffff });

        initScene('bone-container', createBoneModel, (m, t) => {
             // Gentle bobbing
             m.position.y = Math.sin(t) * 0.2;
        }, { rim: 0xffffee });

    </script>
</body>
</html>