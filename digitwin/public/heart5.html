<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heart Medical Visualizer (Clinical Edition)</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
        }

        /* ECG Animation Styles */
        .ecg-grid {
            background-image: linear-gradient(rgba(0, 255, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 0, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .ecg-container {
            position: relative;
            overflow: hidden;
        }

        /* The moving scanning line */
        .ecg-cursor {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #0f0;
            box-shadow: 0 0 10px #0f0;
            z-index: 10;
        }

        input[type="file"] {
            display: none;
        }

        /* Custom Range Slider */
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            margin-top: -5px;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #374151;
            border-radius: 2px;
        }

        .btn-mode {
            @apply px-2 py-1 text-[10px] font-bold rounded border border-gray-600 transition-colors hover:bg-gray-700 uppercase tracking-wider;
        }

        .btn-mode.active {
            @apply bg-red-600 border-red-500 text-white shadow-[0_0_10px_rgba(220, 38, 38, 0.5)];
        }
    </style>
</head>

<body class="font-sans flex flex-col h-screen">

    <!-- TOP HEADER -->
    <div class="bg-gray-900 border-b border-gray-800 p-3 shadow-xl z-20 relative flex justify-between items-center">
        <div class="flex items-center gap-4 pl-12">
            <div class="flex flex-col">
                <h1 class="text-sm font-bold text-gray-200 uppercase tracking-widest flex items-center gap-2">
                    <i data-lucide="heart-pulse" class="w-4 h-4 text-red-500"></i>
                    Cardiac Analysis
                </h1>
                <span class="text-[10px] text-gray-500">DICOM/Image Displacement Engine</span>
            </div>

            <div class="h-8 w-px bg-gray-700 mx-2"></div>

            <label class="flex items-center gap-2 cursor-pointer hover:text-blue-400 transition text-xs text-gray-400">
                <i data-lucide="upload" class="w-4 h-4"></i>
                <span>Upload Scan</span>
                <input type="file" id="file-input" accept="image/*">
            </label>

            <label class="flex items-center gap-2 cursor-pointer hover:text-green-400 transition text-xs text-gray-400">
                <i data-lucide="file-json" class="w-4 h-4"></i>
                <span>Import ECG Data</span>
                <input type="file" id="ecg-input" accept=".json,.csv,.txt">
            </label>
        </div>

        <div class="flex items-center gap-2">
            <button id="mode-btn" class="btn-mode active border-emerald-500 text-white">3D Relief</button>
            <button id="audio-btn" class="p-2 rounded hover:bg-gray-800 text-gray-400 transition-colors">
                <i data-lucide="volume-2" class="w-4 h-4"></i>
            </button>
        </div>
    </div>

    <!-- MAIN LAYOUT -->
    <div class="flex-1 flex relative overflow-hidden bg-black">

        <!-- 3D CANVAS -->
        <div id="canvas-container" class="flex-1 relative bg-gradient-to-b from-gray-900 to-black z-0">
            <!-- Waiting Screen -->
            <div id="waiting-screen"
                class="absolute inset-0 flex flex-col items-center justify-center text-gray-600 pointer-events-none z-10">
                <i data-lucide="scan" class="w-16 h-16 mb-4 opacity-20"></i>
                <p class="text-sm tracking-widest uppercase">Load MRI/CT Scan to Initialize</p>
                <p class="text-[10px] mt-2 text-gray-700">Supported: JPG, PNG</p>
            </div>
        </div>

        <!-- RIGHT SIDEBAR (Controls & Metrics) -->
        <div class="w-72 bg-gray-900 border-l border-gray-800 flex flex-col z-20 shadow-2xl overflow-y-auto">

            <!-- Clinical Metrics -->
            <div class="p-4 border-b border-gray-800 bg-gray-800/50">
                <h3 class="text-[10px] uppercase text-gray-500 font-bold mb-3 flex items-center gap-2">
                    <i data-lucide="activity" class="w-3 h-3"></i> Vitals Telemetry
                </h3>
                <div class="grid grid-cols-2 gap-4">
                    <div class="bg-black/40 p-2 rounded border border-gray-700">
                        <span class="block text-[10px] text-gray-400">HEART RATE</span>
                        <span id="bpm-display" class="text-2xl font-mono text-green-500">--</span>
                        <span class="text-[10px] text-gray-600">BPM</span>
                    </div>
                    <div class="bg-black/40 p-2 rounded border border-gray-700">
                        <span class="block text-[10px] text-gray-400">R-R INTERVAL</span>
                        <span id="rr-display" class="text-2xl font-mono text-blue-500">--</span>
                        <span class="text-[10px] text-gray-600">ms</span>
                    </div>
                </div>
                <div id="pathology-alert"
                    class="hidden mt-3 p-2 bg-red-900/30 border border-red-800 rounded text-red-400 text-xs font-bold text-center animate-pulse">
                    PATHOLOGY DETECTED
                </div>
            </div>

            <!-- Simulation Controls -->
            <div class="p-4 border-b border-gray-800">
                <h3 class="text-[10px] uppercase text-gray-500 font-bold mb-3">Rhythm Simulation</h3>
                <div class="flex flex-wrap gap-2 mb-4">
                    <button class="btn-mode flex-1 active" onclick="setRhythm('normal')">NSR</button>
                    <button class="btn-mode flex-1" onclick="setRhythm('tachycardia')">SVT</button>
                    <button class="btn-mode flex-1" onclick="setRhythm('fibrillation')">AFib</button>
                </div>
            </div>

            <!-- Sliders -->
            <div class="p-4 space-y-5 flex-1">

                <div>
                    <div class="flex justify-between text-xs mb-1">
                        <span class="text-orange-400 font-bold">Stress Load</span>
                        <span id="stress-val">0%</span>
                    </div>
                    <input type="range" id="stress-slider" min="0" max="1" step="0.05" value="0">
                </div>

                <div>
                    <div class="flex justify-between text-xs mb-1">
                        <span class="text-purple-400 font-bold">Arterial Blockage</span>
                        <span id="blockage-val">0%</span>
                    </div>
                    <input type="range" id="blockage-slider" min="0" max="1" step="0.05" value="0">
                    <p id="blockage-hint" class="hidden text-[9px] text-purple-300 mt-1 italic">
                        <i data-lucide="mouse-pointer-2" class="w-3 h-3 inline"></i> Click model to localize blockage
                    </p>
                </div>

                <div>
                    <div class="flex justify-between text-xs mb-1">
                        <span class="text-blue-400 font-bold">Z-Axis Slice</span>
                        <span id="slice-val">100%</span>
                    </div>
                    <input type="range" id="slice-slider" min="0" max="1" step="0.01" value="1">
                </div>
            </div>

            <!-- ECG Mini View -->
            <div class="h-32 bg-black relative border-t border-gray-800 ecg-container">
                <div class="absolute top-1 left-2 text-[9px] text-gray-500">LEAD II (Simulated)</div>
                <div class="ecg-grid w-full h-full opacity-20"></div>
                <canvas id="ecg-canvas" class="w-full h-full block"></canvas>
                <div id="ecg-cursor" class="ecg-cursor"></div>
            </div>
        </div>
    </div>

    <!-- JS LOGIC -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- GLOBAL APP STATE ---
        const state = {
            is3D: true,
            stress: 0,
            blockage: 0,
            blockagePos: new THREE.Vector2(0.5, 0.5),
            slice: 1.0,
            textureLoaded: false,
            rhythm: 'normal',
            audioEnabled: false,
            customECGData: null,
            ecgIndex: 0
        };

        // --- AUDIO ENGINE (RESTORED) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playHeartSound(type) {
            if (!state.audioEnabled || audioCtx.state !== 'running') return;
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            // Simulating heart sounds (Lub-Dub) with filtered sine waves
            osc.frequency.setValueAtTime(type === 'lub' ? 80 : 60, t);
            osc.frequency.exponentialRampToValueAtTime(30, t + 0.1);

            filter.frequency.setValueAtTime(150, t);

            gain.gain.setValueAtTime(0.6, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.12);

            osc.start(t);
            osc.stop(t + 0.15);
        }

        // --- SHADERS (EXACT V1 RENDERING LOGIC + SLICING SUPPORT) ---
        // vertexShader from V1, slightly modified to maintain variable names
        const vertexShader = `
            varying vec2 vUv;
            varying float vDisplacement;
            
            uniform sampler2D uTexture;
            uniform float uPulse; 
            uniform float uDepth; 
            uniform int uIs3D;
            
            void main() {
                vUv = uv;
                
                // Read the image brightness (V1 Logic: Simple Average)
                vec4 color = texture2D(uTexture, uv);
                float brightness = (color.r + color.g + color.b) / 3.0;
                
                vDisplacement = brightness;

                vec3 newPosition = position;

                // 1. 3D Displacement Logic (V1 Logic)
                if (uIs3D == 1) {
                   newPosition.z += brightness * uDepth;
                }

                // 2. Heartbeat Logic (V1 Logic)
                float beatIntensity = uPulse * 0.15 * brightness; 
                newPosition += normal * beatIntensity;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
            }
        `;

        // fragmentShader from V1, adapted ONLY to support Slice/BlockagePos
        const fragmentShader = `
            varying vec2 vUv;
            varying float vDisplacement;
            
            uniform sampler2D uTexture;
            uniform float uStressLevel; 
            uniform float uBlockage;    
            uniform vec2 uBlockagePos; 
            uniform float uSlice;
            
            void main() {
                // Keep Slicing (Feature to Retain)
                if (vUv.y > uSlice) discard;

                vec4 texColor = texture2D(uTexture, vUv);
                
                // Discard black background (V1 Logic)
                if (texColor.r < 0.1 && texColor.g < 0.1 && texColor.b < 0.1) {
                    discard;
                }

                vec3 finalColor = texColor.rgb;

                // --- Stress Heatmap (V1 Logic) ---
                vec3 stressColor = vec3(1.0, 0.2, 0.0);
                float stressIntensity = uStressLevel * vDisplacement; 
                finalColor = mix(finalColor, stressColor, stressIntensity * 0.8);

                // --- Blockage Simulation (Adapted V1 Logic for dynamic position) ---
                if (uBlockage > 0.0) {
                    float dist = distance(vUv, uBlockagePos);
                    float zoneRadius = 0.15 + (uBlockage * 0.2); 
                    
                    if (dist < zoneRadius) {
                        // V1 Color
                        vec3 deadTissueColor = vec3(0.1, 0.0, 0.2); 
                        
                        // Simple mixing like V1, but using smoothstep for cleanliness
                        float blendFactor = smoothstep(zoneRadius, 0.0, dist) * uBlockage;
                        finalColor = mix(finalColor, deadTissueColor, blendFactor);
                    }
                }

                // No derivative lighting. No Fresnel. No Flush. Exact V1 output.
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // --- THREE.JS SCENE SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
        camera.position.set(0, 5, 4);

        // Standard Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 1.5;

        // Lights (V1 didn't really use them in shader, but good for scene)
        const ambLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambLight);

        // --- OBJECTS ---
        let planeMesh, particleMesh, markerMesh;
        const dummy = new THREE.Object3D();
        const particles = [];
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function initScene(texture) {
            // Plane
            const geometry = new THREE.PlaneGeometry(5, 5, 256, 256);
            const material = new THREE.ShaderMaterial({
                vertexShader, fragmentShader,
                uniforms: {
                    uTexture: { value: texture },
                    uPulse: { value: 0 },
                    uDepth: { value: 1.5 },
                    uIs3D: { value: 1 },
                    uStressLevel: { value: 0 },
                    uBlockage: { value: 0 },
                    uBlockagePos: { value: new THREE.Vector2(0.5, 0.5) },
                    uSlice: { value: 1.0 }
                },
                side: THREE.DoubleSide,
                transparent: true
                // No extensions required for V1 shaders
            });
            if (planeMesh) scene.remove(planeMesh);
            planeMesh = new THREE.Mesh(geometry, material);
            planeMesh.rotation.x = -Math.PI / 2;
            scene.add(planeMesh);

            // Marker
            if (markerMesh) scene.remove(markerMesh);
            markerMesh = new THREE.Mesh(
                new THREE.RingGeometry(0.1, 0.12, 32),
                new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8, side: THREE.DoubleSide })
            );
            markerMesh.visible = false;
            markerMesh.rotation.x = -Math.PI / 2;
            scene.add(markerMesh);

            // Particles
            if (particleMesh) scene.remove(particleMesh);
            particleMesh = new THREE.InstancedMesh(
                new THREE.SphereGeometry(0.03, 4, 4),
                new THREE.MeshBasicMaterial({ color: 0xcc0000 }),
                1000
            );
            particles.length = 0;
            for (let i = 0; i < 1000; i++) particles.push({
                x: (Math.random() - 0.5) * 5, y: (Math.random() - 0.5) * 5, speed: Math.random() * 0.02 + 0.01, offset: Math.random() * 10
            });
            scene.add(particleMesh);

            state.textureLoaded = true;
            document.getElementById('waiting-screen').style.display = 'none';
        }

        // --- ECG & ANIMATION ENGINE ---
        const ecgCanvas = document.getElementById('ecg-canvas');
        const ecgCtx = ecgCanvas.getContext('2d');
        const ecgCursor = document.getElementById('ecg-cursor');

        // Resize ECG canvas
        ecgCanvas.width = ecgCanvas.clientWidth;
        ecgCanvas.height = ecgCanvas.clientHeight;

        let ecgHistory = new Array(300).fill(0.5);

        function getECGValue(time) {
            // 1. If Custom Data exists, use it
            if (state.customECGData && state.customECGData.length > 0) {
                const fps = 60;
                const index = Math.floor(time * fps) % state.customECGData.length;
                const val = state.customECGData[index];
                if (val > 0.8 && state.customECGData[index - 1] <= 0.8) {
                    playHeartSound('lub');
                    setTimeout(() => playHeartSound('dub'), 200);
                }
                return val;
            }

            // 2. Procedural Simulation
            let t, val = 0;
            let bpm = 60;

            if (state.rhythm === 'tachycardia') {
                t = time * 5.0; bpm = 140;
            } else if (state.rhythm === 'fibrillation') {
                t = time * 4.0; bpm = 0;
                val = (Math.sin(t * 10) * 0.1 + Math.sin(t * 23) * 0.1) * 0.3;
                if (Math.random() > 0.96) val += 0.5;
                return Math.max(0, val);
            } else {
                t = time * 3.0; bpm = 75;
            }

            const p = Math.exp(-Math.pow(t % 3 - 0.4, 2) / 0.02) * 0.15;
            const qrs = -1.0 * Math.exp(-Math.pow(t % 3 - 0.9, 2) / 0.005) +
                2.5 * Math.exp(-Math.pow(t % 3 - 0.95, 2) / 0.003) +
                -0.5 * Math.exp(-Math.pow(t % 3 - 1.0, 2) / 0.005);
            const tWave = Math.exp(-Math.pow(t % 3 - 1.6, 2) / 0.15) * 0.3;
            val = Math.max(0, p + qrs + tWave);

            const beatGap = state.rhythm === 'tachycardia' ? 0.3 : 0.8;
            if (val > 0.8 && (time - state.lastBeat > beatGap)) {
                state.lastBeat = time;
                playHeartSound('lub');
                setTimeout(() => playHeartSound('dub'), 150);
            }

            if (state.rhythm === 'fibrillation') {
                if (Math.random() > 0.9) document.getElementById('bpm-display').innerText = Math.floor(80 + Math.random() * 60);
                document.getElementById('rr-display').innerText = "IRREG";
            } else {
                document.getElementById('bpm-display').innerText = bpm;
                document.getElementById('rr-display').innerText = Math.round(60000 / bpm);
            }

            return val;
        }

        state.lastBeat = 0;

        function updateECGVisual(val) {
            ecgHistory.push(val);
            ecgHistory.shift();

            ecgCtx.clearRect(0, 0, ecgCanvas.width, ecgCanvas.height);
            ecgCtx.beginPath();
            ecgCtx.strokeStyle = state.rhythm === 'fibrillation' ? '#ef4444' : '#22c55e';
            ecgCtx.lineWidth = 2;

            const step = ecgCanvas.width / ecgHistory.length;

            for (let i = 0; i < ecgHistory.length; i++) {
                const y = ecgCanvas.height - (ecgHistory[i] * ecgCanvas.height * 0.8) - 10;
                if (i === 0) ecgCtx.moveTo(i * step, y);
                else ecgCtx.lineTo(i * step, y);
            }
            ecgCtx.stroke();
            ecgCursor.style.left = '98%';
        }

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            if (!state.textureLoaded) return;

            const time = clock.getElapsedTime();
            const pulse = getECGValue(time);
            updateECGVisual(pulse);

            if (planeMesh) {
                planeMesh.material.uniforms.uPulse.value = pulse;
                planeMesh.material.uniforms.uStressLevel.value = state.stress;
                planeMesh.material.uniforms.uBlockage.value = state.blockage;
                planeMesh.material.uniforms.uBlockagePos.value = state.blockagePos;
                planeMesh.material.uniforms.uSlice.value = state.slice;
                planeMesh.material.uniforms.uIs3D.value = state.is3D ? 1 : 0;
            }

            if (markerMesh) {
                markerMesh.visible = state.blockage > 0;
                if (markerMesh.visible) {
                    markerMesh.position.set((state.blockagePos.x - 0.5) * 5, state.is3D ? 0.6 : 0.05, (0.5 - state.blockagePos.y) * 5);
                }
            }

            if (particleMesh) {
                const flowMult = Math.max(0.1, 1.0 - state.blockage);
                particles.forEach((p, i) => {
                    let spd = p.speed * flowMult;
                    if (pulse > 0.5) spd *= 3.0;

                    p.y -= spd;
                    const uvY = 1.0 - ((p.y + 2.5) / 5.0);

                    if (p.y < -2.5 || uvY > state.slice) {
                        p.y = 2.5; p.x = (Math.random() - 0.5) * 4.5;
                    }

                    dummy.position.set(p.x, 0.1 + (pulse * 0.3), p.y);
                    const s = (uvY > state.slice) ? 0 : 0.5 + (flowMult * 0.5);
                    dummy.scale.set(s, s, s);
                    dummy.updateMatrix();
                    particleMesh.setMatrixAt(i, dummy.matrix);
                });
                particleMesh.instanceMatrix.needsUpdate = true;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // --- EVENTS ---

        document.getElementById('file-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            new THREE.TextureLoader().load(url, (tex) => {
                tex.minFilter = THREE.LinearFilter;
                tex.magFilter = THREE.LinearFilter;
                initScene(tex);
            });
        });

        document.getElementById('ecg-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                try {
                    const data = JSON.parse(evt.target.result);
                    if (Array.isArray(data)) {
                        state.customECGData = data;
                        document.getElementById('bpm-display').innerText = "CUSTOM";
                        alert("Custom ECG Data Loaded!");
                    }
                } catch (err) {
                    alert("Invalid JSON format. Please upload an array of numbers.");
                }
            };
            reader.readAsText(file);
        });

        document.getElementById('mode-btn').addEventListener('click', (e) => {
            state.is3D = !state.is3D;
            e.target.classList.toggle('active');
        });

        document.getElementById('stress-slider').addEventListener('input', (e) => {
            state.stress = parseFloat(e.target.value);
            document.getElementById('stress-val').textContent = Math.round(state.stress * 100) + "%";
        });
        document.getElementById('blockage-slider').addEventListener('input', (e) => {
            state.blockage = parseFloat(e.target.value);
            document.getElementById('blockage-val').textContent = Math.round(state.blockage * 100) + "%";
            document.getElementById('blockage-hint').classList.remove('hidden');
            if (state.blockage > 0.8) document.getElementById('pathology-alert').classList.remove('hidden');
            else document.getElementById('pathology-alert').classList.add('hidden');
        });
        document.getElementById('slice-slider').addEventListener('input', (e) => {
            state.slice = parseFloat(e.target.value);
            document.getElementById('slice-val').textContent = Math.round(state.slice * 100) + "%";
        });

        document.getElementById('canvas-container').addEventListener('pointerdown', (e) => {
            if (!planeMesh) return;
            const rect = container.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(planeMesh);
            if (intersects.length > 0) {
                state.blockagePos.copy(intersects[0].uv);
            }
        });

        document.getElementById('audio-btn').addEventListener('click', (e) => {
            state.audioEnabled = !state.audioEnabled;
            if (state.audioEnabled) audioCtx.resume();
            e.currentTarget.classList.toggle('text-green-400');
        });

        window.setRhythm = (r) => {
            state.rhythm = r;
            state.customECGData = null;
            document.querySelectorAll('.btn-mode').forEach(b => b.classList.remove('active'));
        };

        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            ecgCanvas.width = ecgCanvas.clientWidth;
            ecgCanvas.height = ecgCanvas.clientHeight;
        });

        lucide.createIcons();
    </script>
</body>

</html>